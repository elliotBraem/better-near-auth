# Better Auth Plugin Architecture & Better-Near-Auth Implementation Guide

## Overview

Better Auth is a framework-agnostic authentication and authorization framework for TypeScript that uses a powerful plugin system to extend functionality. This document explains how Better Auth plugins work and provides comprehensive technical documentation for the better-near-auth plugin, which implements Sign in with NEAR (SIWN) following the NEP-413 standard.

## Better Auth Plugin Architecture

### Core Plugin Concepts

Better Auth plugins consist of two main components:
1. **Server Plugin**: Handles backend logic, database operations, and API endpoints
2. **Client Plugin**: Provides frontend interface and type-safe API calls

### Server Plugin Structure

A Better Auth server plugin is an object that satisfies the `BetterAuthPlugin` interface:

```typescript
import type { BetterAuthPlugin } from "better-auth";

export const myPlugin = (options: PluginOptions) => ({
    id: "my-plugin",           // Unique identifier
    schema: { /* ... */ },     // Database schema extensions
    endpoints: { /* ... */ },  // Custom API endpoints
    hooks: { /* ... */ },      // Request/response middleware
    rateLimit: { /* ... */ },  // Rate limiting rules
}) satisfies BetterAuthPlugin;
```

### Client Plugin Structure

Client plugins provide type-safe interfaces to server endpoints:

```typescript
import type { BetterAuthClientPlugin } from "better-auth/client";

export const myPluginClient = () => ({
    id: "my-plugin",
    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    getActions: ($fetch) => ({ /* custom actions */ }),
    getAtoms: ($fetch) => ({ /* state management */ }),
    pathMethods: { /* HTTP method overrides */ }
}) satisfies BetterAuthClientPlugin;
```

### Key Plugin Components

1. **Schema**: Extends database with custom tables and fields
2. **Endpoints**: Creates custom API routes with validation
3. **Hooks**: Intercepts requests before/after processing
4. **Actions**: Client-side methods for API interaction
5. **Type Inference**: Automatic type safety between client/server

## Better-Near-Auth Plugin Implementation

### Architecture Overview

The better-near-auth plugin implements NEP-413 (Sign in with NEAR) standard, providing:
- Secure wallet-based authentication using a two-step process
- NEAR account linking to user profiles
- Profile integration with NEAR Social
- Embedded fastintear client for wallet connectivity
- Support for both mainnet and testnet networks

### Server Plugin Implementation

```typescript
export const siwn = (options: SIWNPluginOptions) => ({
    id: "siwn",
    schema,
    endpoints: {
        getSiwnNonce: createAuthEndpoint("/near/nonce", /* ... */),
        getSiwnProfile: createAuthEndpoint("/near/profile", /* ... */),
        verifySiwnMessage: createAuthEndpoint("/near/verify", /* ... */),
    },
}) satisfies BetterAuthPlugin;
```

### Database Schema

The plugin extends the database with a `nearAccount` table:

```typescript
export const schema = {
    nearAccount: {
        fields: {
            userId: {
                type: "string",
                references: { model: "user", field: "id" },
                required: true,
            },
            accountId: { type: "string", required: true },
            network: { type: "string", required: true },
            publicKey: { type: "string", required: true },
            isPrimary: { type: "boolean", defaultValue: false },
            createdAt: { type: "date", required: true },
        },
    },
} satisfies AuthPluginSchema;
```

### API Endpoints

#### 1. Nonce Generation (`/near/nonce`)
Generates cryptographic nonces for signature verification:

```typescript
getSiwnNonce: createAuthEndpoint("/near/nonce", {
    method: "POST",
    body: NonceRequest, // { accountId: string, publicKey: string, networkId: string }
}, async (ctx) => {
    const { accountId, publicKey, networkId } = ctx.body;
    const network = getNetworkFromAccountId(accountId);
    
    if (networkId !== network) {
        throw new APIError("BAD_REQUEST", {
            message: "Network ID mismatch with account ID",
            status: 400,
        });
    }

    const nonce = options.getNonce ? await options.getNonce() : generateNonce();
    
    // Store nonce with accountId, network, and publicKey for unique identification
    await ctx.context.internalAdapter.createVerificationValue({
        identifier: `siwn:${accountId}:${network}:${publicKey}`,
        value: bytesToBase64(nonce),
        expiresAt: new Date(Date.now() + 15 * 60 * 1000),
    });
    
    return ctx.json({ nonce: bytesToBase64(nonce) });
})
```

#### 2. Profile Retrieval (`/near/profile`)
Fetches user profiles from NEAR Social:

```typescript
getSiwnProfile: createAuthEndpoint("/near/profile", {
    method: "POST",
    body: ProfileRequest, // { accountId?: string }
    use: [sessionMiddleware],
}, async (ctx) => {
    const { accountId } = ctx.body;
    let targetAccountId = accountId;
    
    // If no accountId provided, use authenticated user's primary account
    if (!targetAccountId) {
        const session = ctx.context.session;
        if (!session) {
            throw new APIError("UNAUTHORIZED", {
                message: "Session required when no accountId provided",
            });
        }
        
        const nearAccount = await ctx.context.adapter.findOne({
            model: "nearAccount",
            where: [
                { field: "userId", operator: "eq", value: session.user.id },
                { field: "isPrimary", operator: "eq", value: true },
            ],
        });
        
        targetAccountId = nearAccount?.accountId;
    }
    
    const profile = await (options.getProfile || defaultGetProfile)(targetAccountId);
    return ctx.json(profile);
})
```

#### 3. Signature Verification (`/near/verify`)
Verifies NEAR signatures and creates/updates user sessions:

```typescript
verifySiwnMessage: createAuthEndpoint("/near/verify", {
    method: "POST",
    body: VerifyRequest.refine((data) => 
        options.anonymous !== false || !!data.email, {
        message: "Email is required when anonymous is disabled.",
        path: ["email"],
    }),
}, async (ctx) => {
    const { authToken, accountId, email } = ctx.body;
    const network = getNetworkFromAccountId(accountId);
    
    // Parse the auth token to get the public key
    const { publicKey } = parseAuthToken(authToken);
    
    // Retrieve and validate nonce using the same identifier format
    const verification = await ctx.context.internalAdapter.findVerificationValue(
        `siwn:${accountId}:${network}:${publicKey}`
    );
    
    // Verify signature using near-sign-verify
    const verifyOptions: VerifyOptions = {
        requireFullAccessKey: options.requireFullAccessKey ?? true,
        ...(options.validateNonce 
            ? { validateNonce: options.validateNonce }
            : { nonceMaxAge: 15 * 60 * 1000 }),
        ...(options.validateRecipient 
            ? { validateRecipient: options.validateRecipient }
            : { expectedRecipient: options.recipient }),
    };
    
    const result = await verify(authToken, verifyOptions);
    
    // Create or update user and NEAR account records
    // Create session and set cookies
    // Return authentication response
})
```

### Client Plugin Implementation

The client plugin uses an embedded fastintear client and implements a **two-step authentication flow**:

```typescript
export const siwnClient = (config: SIWNClientConfig) => {
    // Create embedded NEAR client
    const nearClient = fastintear.createNearClient({
        networkId: config.networkId || "mainnet"
    });

    // Create atoms for caching nonce data
    const cachedNonce = atom<CachedNonceData | null>(null);

    return {
        id: "siwn",
        $InferServerPlugin: {} as ReturnType<typeof siwn>,
        getActions: ($fetch) => ({
            near: {
                nonce: async (params) => $fetch("/near/nonce", {
                    method: "POST",
                    body: params,
                }),
                verify: async (params) => $fetch("/near/verify", {
                    method: "POST", 
                    body: params,
                }),
                getProfile: async (accountId) => $fetch("/near/profile", {
                    method: "POST",
                    body: { accountId },
                }),
                getNearClient: () => nearClient,
                getAccountId: () => nearClient.accountId(),
                disconnect: async () => {
                    await nearClient.signOut();
                    clearNonce();
                },
            },
            requestSignIn: {
                near: async (params, callbacks) => {
                    // Step 1: Connect wallet and get nonce
                    const { recipient } = params;
                    
                    await nearClient.requestSignIn({ contractId: recipient }, {
                        onSuccess: async ({ accountId, publicKey, networkId }) => {
                            // Request nonce from server
                            const nonceResponse = await $fetch("/near/nonce", {
                                method: "POST",
                                body: { accountId, publicKey, networkId }
                            });
                            
                            // Cache nonce data for step 2
                            cachedNonce.set({
                                nonce: nonceResponse.data.nonce,
                                accountId,
                                publicKey,
                                networkId,
                                timestamp: Date.now()
                            });
                            
                            callbacks?.onSuccess?.();
                        },
                        onError: callbacks?.onError
                    });
                }
            },
            signIn: {
                near: async (params, callbacks) => {
                    // Step 2: Sign message and authenticate
                    const { recipient } = params;
                    
                    const accountId = nearClient.accountId();
                    if (!accountId) {
                        throw new Error("Wallet not connected. Please call requestSignIn first.");
                    }
                    
                    // Retrieve cached nonce
                    const nonceData = cachedNonce.get();
                    if (!isNonceValid(nonceData)) {
                        throw new Error("No valid nonce found. Please call requestSignIn first.");
                    }
                    
                    const { nonce } = nonceData;
                    
                    // Create and sign the NEP-413 message
                    const message = `Sign in to ${recipient}\n\nAccount ID: ${accountId}\nNonce: ${nonce}`;
                    const nonceBytes = base64ToBytes(nonce);
                    
                    const authToken = await sign(message, {
                        signer: nearClient,
                        recipient,
                        nonce: nonceBytes,
                    });
                    
                    // Verify and authenticate with server
                    const verifyResponse = await $fetch("/near/verify", {
                        method: "POST",
                        body: { authToken, accountId }
                    });
                    
                    clearNonce();
                    callbacks?.onSuccess?.();
                    return verifyResponse.data;
                }
            }
        })
    } satisfies BetterAuthClientPlugin;
};
```

### Type Definitions

The plugin uses comprehensive Zod schemas for type safety:

```typescript
// Account ID validation
export const accountIdSchema = z.string()
    .min(2)
    .max(64)
    .regex(/^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/, 
           "Invalid NEAR account ID format");

// Profile structure from NEAR Social
export const profileSchema = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    image: z.object({
        url: z.string().optional(),
        ipfs_cid: z.string().optional(),
    }).optional(),
    backgroundImage: z.object({
        url: z.string().optional(),
        ipfs_cid: z.string().optional(),
    }).optional(),
    linktree: z.record(z.string(), z.string()).optional(),
});

// API request/response schemas
export const NonceRequest = z.object({ 
    accountId: accountIdSchema,
    publicKey: z.string(),
    networkId: z.string()
});
export const VerifyRequest = z.object({
    authToken: z.string().min(1),
    accountId: accountIdSchema,
    email: z.email().optional(),
});
export const ProfileRequest = z.object({
    accountId: accountIdSchema.optional(),
});

export const NonceResponse = z.object({ nonce: z.string() });
export const VerifyResponse = z.object({
    token: z.string(),
    success: z.literal(true),
    user: z.object({
        id: z.string(),
        accountId: accountIdSchema,
        network: z.union([z.literal("mainnet"), z.literal("testnet")]),
    }),
});
```

## Integration Patterns

### Browser Wallet Integration with Fastintear

The plugin uses an embedded fastintear client for wallet connectivity:

```typescript
// Client configuration
export const authClient = createAuthClient({
    plugins: [
        siwnClient({
            domain: "myapp.com",
            networkId: "mainnet", // or "testnet"
        })
    ],
});

// Two-step authentication flow
// Step 1: Connect wallet and get nonce
await authClient.requestSignIn.near(
    { recipient: "myapp.com" },
    {
        onSuccess: () => console.log("Wallet connected, nonce cached!"),
        onError: (error) => console.error("Wallet connection failed:", error),
    }
);

// Step 2: Sign message and authenticate
await authClient.signIn.near(
    { recipient: "myapp.com" },
    {
        onSuccess: () => console.log("Signed in!"),
        onError: (error) => console.error("Sign in failed:", error),
    }
);
```

## Configuration Options

### Server Plugin Options

```typescript
export type SIWNPluginOptions = {
    recipient: string;                    // Required: NEP-413 recipient
    anonymous?: boolean;                  // Allow anonymous sign-ins (default: true)
    emailDomainName?: string;            // Email domain for user accounts
    requireFullAccessKey?: boolean;       // Require full access keys (default: true)
    getNonce?: () => Promise<Uint8Array>; // Custom nonce generation
    validateNonce?: (nonce: Uint8Array) => boolean; // Custom nonce validation
    validateRecipient?: (recipient: string) => boolean; // Custom recipient validation
    validateMessage?: (message: string) => boolean; // Custom message validation
    getProfile?: (accountId: string) => Promise<Profile | null>; // Custom profile lookup
    validateLimitedAccessKey?: (args: {
        accountId: string;
        publicKey: string;
        recipient?: string;
    }) => Promise<boolean>; // Validate function call keys
};
```

### Client Plugin Options

```typescript
export interface SIWNClientConfig {
    domain: string;                      // Domain identifier (for display purposes)
    networkId?: "mainnet" | "testnet";   // NEAR network (default: "mainnet")
}
```

### Advanced Configuration Example

```typescript
import { betterAuth } from "better-auth";
import { siwn } from "better-near-auth";
import { generateNonce } from "near-sign-verify";

const usedNonces = new Set<string>();

export const auth = betterAuth({
    plugins: [
        siwn({
            recipient: "myapp.com",
            anonymous: false,
            emailDomainName: "myapp.com",
            requireFullAccessKey: false,
            
            // Custom nonce generation
            getNonce: async () => generateNonce(),
            
            // Prevent replay attacks
            validateNonce: (nonce: Uint8Array) => {
                const nonceHex = Array.from(nonce)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                if (usedNonces.has(nonceHex)) {
                    return false;
                }
                usedNonces.add(nonceHex);
                return true;
            },
            
            // Allow multiple domains
            validateRecipient: (recipient: string) => {
                const allowedRecipients = [
                    "myapp.com", 
                    "staging.myapp.com", 
                    "localhost:3000"
                ];
                return allowedRecipients.includes(recipient);
            },
            
            // Custom profile lookup
            getProfile: async (accountId) => {
                try {
                    const response = await fetch(`https://api.myapp.com/profiles/${accountId}`);
                    if (response.ok) {
                        const customProfile = await response.json();
                        return {
                            name: customProfile.displayName,
                            description: customProfile.bio,
                            image: { url: customProfile.avatar },
                        };
                    }
                } catch (error) {
                    console.error("Custom profile fetch failed:", error);
                }
                return null; // Fallback to NEAR Social
            },
            
            // Validate function call keys
            validateLimitedAccessKey: async ({ accountId, publicKey, recipient }) => {
                const allowedContracts = ["myapp.near", "social.near"];
                return recipient ? allowedContracts.includes(recipient) : true;
            },
        }),
    ],
});
```

## Authentication Flow

### Complete Two-Step Authentication Sequence

1. **Step 1 - Wallet Connection & Nonce Request**:
   - User calls `authClient.requestSignIn.near()`
   - Client connects to NEAR wallet via fastintear
   - Client requests nonce from server with `{ accountId, publicKey, networkId }`
   - Server generates and stores nonce with unique identifier
   - Client caches nonce data locally

2. **Step 2 - Message Signing & Verification**:
   - User calls `authClient.signIn.near()`
   - Client retrieves cached nonce data
   - Client creates NEP-413 compliant message
   - Client signs message using wallet
   - Client sends auth token to server for verification
   - Server verifies signature and creates session

### Error Handling

The plugin provides comprehensive error handling:

```typescript
// Common error scenarios
- UNAUTHORIZED_INVALID_OR_EXPIRED_NONCE: Nonce expired or invalid
- BAD_REQUEST: Missing required fields or network mismatch
- UNAUTHORIZED: Account ID mismatch or signature verification failed
- NOT_FOUND: No NEAR account found for authenticated user
- INTERNAL_SERVER_ERROR: Session creation failed
- WALLET_NOT_CONNECTED: Wallet not connected before signing
- NONCE_NOT_FOUND: No valid cached nonce found
- ACCOUNT_MISMATCH: Cached nonce doesn't match current account
```

## Security Considerations

### NEP-413 Compliance
- Follows NEAR Enhancement Proposal 413 for secure message signing
- Implements proper nonce handling to prevent replay attacks
- Validates message format and recipient information

### Nonce Management
- Unique nonce storage per account/network/publicKey combination
- 15-minute expiration for nonces
- Automatic cleanup after successful authentication
- Client-side caching with validation

### Access Key Validation
- Supports both full access keys and function call access keys
- Configurable validation for limited access keys
- Contract-specific access control when using function call keys

### Session Security
- Secure cookie handling with proper expiration
- Session token generation and validation
- Multi-account support with primary account designation

## Network Support

### Automatic Network Detection
```typescript
export const getNetworkFromAccountId = (accountId: string): "mainnet" | "testnet" => {
    return accountId.endsWith(".testnet") ? "testnet" : "mainnet";
};
```

### Multi-Network Account Linking
- Supports both mainnet and testnet accounts
- Separate account records per network
- Network-specific nonce storage and validation

## Profile Integration

### NEAR Social Integration
The plugin automatically fetches user profiles from NEAR Social:

```typescript
export const defaultGetProfile = async (accountId: string): Promise<Profile | null> => {
    const network = getNetworkFromAccountId(accountId);
    const apiBase = {
        mainnet: "https://api.near.social",
        testnet: "https://test.api.near.social",
    }[network];

    const keys = [`${accountId}/profile/**`];

    try {
        const response = await fetch(`${apiBase}/get`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ keys })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const profile = data?.[accountId]?.profile;

        return profile ? {
            name: profile.name,
            description: profile.description,
            image: profile.image,
            backgroundImage: profile.backgroundImage,
            linktree: profile.linktree
        } : null;
    } catch (error) {
        return null;
    }
};
```

### Custom Profile Sources
Configure custom profile lookup functions:

```typescript
siwn({
    getProfile: async (accountId) => {
        // Custom profile logic
        const customProfile = await fetchFromCustomAPI(accountId);
        if (customProfile) {
            return {
                name: customProfile.displayName,
                description: customProfile.bio,
                image: { url: customProfile.avatar },
            };
        }
        // Fallback to NEAR Social
        return null;
    },
})
```

## Usage Examples

### Basic Setup

```typescript
// Server (auth.ts)
import { betterAuth } from "better-auth";
import { siwn } from "better-near-auth";

export const auth = betterAuth({
    database: drizzleAdapter(db),
    plugins: [
        siwn({
            recipient: "myapp.com",
            anonymous: true,
        }),
    ],
});

// Client (auth-client.ts)
import { createAuthClient } from "better-auth/client";
import { siwnClient } from "better-near-auth/client";

export const authClient = createAuthClient({
    plugins: [
        siwnClient({
            domain: "myapp.com",
            networkId: "mainnet",
        })
    ],
});
```

### React Component Example

```tsx
import { authClient } from "./auth-client";
import { useState } from "react";

export function LoginButton() {
    const { data: session } = authClient.useSession();
    const [isConnectingWallet, setIsConnectingWallet] = useState(false);
    const [isSigningIn, setIsSigningIn] = useState(false);
    
    // Get account ID from embedded client
    const accountId = authClient.near.getAccountId();

    if (session) {
        return (
            <div>
                <p>Welcome, {session.user.name}!</p>
                <button onClick={() => authClient.signOut()}>
                    Sign out
                </button>
            </div>
        );
    }

    const handleWalletConnect = async () => {
        setIsConnectingWallet(true);
        
        try {
            await authClient.requestSignIn.near(
                { recipient: "myapp.com" },
                {
                    onSuccess: () => {
                        setIsConnectingWallet(false);
                        console.log("Wallet connected!");
                    },
                    onError: (error) => {
                        setIsConnectingWallet(false);
                        console.error("Wallet connection failed:", error.message);
                    },
                }
            );
        } catch (error) {
            setIsConnectingWallet(false);
            console.error("Authentication error:", error);
        }
    };

    const handleSignIn = async () => {
        setIsSigningIn(true);
        
        try {
            await authClient.signIn.near(
                { recipient: "myapp.com" },
                {
                    onSuccess: () => {
                        setIsSigningIn(false);
                        console.log("Successfully signed in!");
                    },
                    onError: (error) => {
                        setIsSigningIn(false);
                        console.error("Sign in failed:", error.message);
                    },
                }
            );
        } catch (error) {
            setIsSigningIn(false);
            console.error("Authentication error:", error);
        }
    };

    return (
        <div>
            {!accountId ? (
                <button onClick={handleWalletConnect} disabled={isConnectingWallet}>
                    {isConnectingWallet ? "Connecting..." : "Connect NEAR Wallet"}
                </button>
            ) : (
                <button onClick={handleSignIn} disabled={isSigningIn}>
                    {isSigningIn ? "Signing in..." : `Sign in with NEAR (${accountId})`}
                </button>
            )}
        </div>
    );
}
```

### Profile Access

```typescript
// Get current user's profile (requires authentication)
const myProfile = await authClient.near.getProfile();
console.log("My profile:", myProfile);

// Get specific user's profile (no auth required)
const aliceProfile = await authClient.near.getProfile("alice.near");
console.log("Alice's profile:", aliceProfile);
```

## Best Practices

### Security
1. Always validate nonces to prevent replay attacks
2. Use HTTPS in production for secure cookie transmission
3. Implement proper error handling and user feedback
4. Validate recipient domains to prevent phishing attacks
5. Use the two-step flow to ensure proper wallet connection

### Performance
1. Cache profile data when appropriate
2. Use connection pooling for database operations
3. Implement rate limiting for authentication endpoints
4. Leverage the embedded fastintear client for efficiency

### User Experience
1. Provide clear error messages for authentication failures
2. Handle wallet connection states gracefully
3. Support both anonymous and email-required modes
4. Implement loading states during both authentication steps
5. Show wallet connection status to users

## Troubleshooting

### Common Issues

1. **"Wallet not connected"**
   - User must call `requestSignIn.near()` before `signIn.near()`
   - Check that the embedded fastintear client is properly initialized

2. **"No valid nonce found"**
   - Ensure `requestSignIn.near()` completed successfully before calling `signIn.near()`
   - Nonces expire after 5 minutes in the client cache

3. **"Invalid or expired nonce"**
   - Server nonces expire after 15 minutes
   - Ensure client and server clocks are synchronized

4. **"Account ID mismatch"**
   - Verify the signed message contains the correct account ID
   - Check for wallet switching between the two authentication steps

5. **"Network ID mismatch"**
   - Ensure the networkId sent to the server matches the account's network
   - Testnet accounts must use "testnet", mainnet accounts use "mainnet"

### Debug Mode

Enable debug logging for troubleshooting:

```typescript
// Add to your auth configuration
siwn({
    // ... other options
    validateMessage: (message: string) => {
        console.log("Validating message:", message);
        return true; // Add your validation logic
    },
    validateNonce: (nonce: Uint8Array) => {
        console.log("Validating nonce:", Array.from(nonce));
        return true; // Add your validation logic
    },
})
```

## Conclusion

The better-near-auth plugin demonstrates the power and flexibility of Better Auth's plugin architecture. By following the established patterns for server and client plugins, it provides a complete authentication solution that integrates seamlessly with the NEAR ecosystem while maintaining type safety and security best practices.

The plugin's two-step authentication flow ensures proper wallet connectivity while the embedded fastintear client provides a seamless user experience. The modular design allows for extensive customization while providing sensible defaults for common use cases. Whether you're building a simple dApp or a complex federated service, better-near-auth provides the foundation for secure NEAR-based authentication.

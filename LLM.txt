# Better Auth Plugin Architecture & Better-Near-Auth Implementation Guide

## Overview

Better Auth is a framework-agnostic authentication and authorization framework for TypeScript that uses a powerful plugin system to extend functionality. This document explains how Better Auth plugins work and provides comprehensive technical documentation for the better-near-auth plugin, which implements Sign in with NEAR (SIWN) following the NEP-413 standard.

## Better Auth Plugin Architecture

### Core Plugin Concepts

Better Auth plugins consist of two main components:
1. **Server Plugin**: Handles backend logic, database operations, and API endpoints
2. **Client Plugin**: Provides frontend interface and type-safe API calls

### Server Plugin Structure

A Better Auth server plugin is an object that satisfies the `BetterAuthPlugin` interface:

```typescript
import type { BetterAuthPlugin } from "better-auth";

export const myPlugin = (options: PluginOptions) => ({
    id: "my-plugin",           // Unique identifier
    schema: { /* ... */ },     // Database schema extensions
    endpoints: { /* ... */ },  // Custom API endpoints
    hooks: { /* ... */ },      // Request/response middleware
    rateLimit: { /* ... */ },  // Rate limiting rules
}) satisfies BetterAuthPlugin;
```

### Client Plugin Structure

Client plugins provide type-safe interfaces to server endpoints:

```typescript
import type { BetterAuthClientPlugin } from "better-auth/client";

export const myPluginClient = () => ({
    id: "my-plugin",
    $InferServerPlugin: {} as ReturnType<typeof myPlugin>,
    getActions: ($fetch) => ({ /* custom actions */ }),
    getAtoms: ($fetch) => ({ /* state management */ }),
    pathMethods: { /* HTTP method overrides */ }
}) satisfies BetterAuthClientPlugin;
```

### Key Plugin Components

1. **Schema**: Extends database with custom tables and fields
2. **Endpoints**: Creates custom API routes with validation
3. **Hooks**: Intercepts requests before/after processing
4. **Actions**: Client-side methods for API interaction
5. **Type Inference**: Automatic type safety between client/server

## Better-Near-Auth Plugin Implementation

### Architecture Overview

The better-near-auth plugin implements NEP-413 (Sign in with NEAR) standard, providing:
- Secure wallet-based authentication
- NEAR account linking to user profiles
- Profile integration with NEAR Social
- Support for both browser wallets and server-to-server authentication

### Server Plugin Implementation

```typescript
export const siwn = (options: SIWNPluginOptions) => ({
    id: "siwn",
    schema,
    endpoints: {
        getSiwnNonce: createAuthEndpoint("/near/nonce", /* ... */),
        getSiwnProfile: createAuthEndpoint("/near/profile", /* ... */),
        verifySiwnMessage: createAuthEndpoint("/near/verify", /* ... */),
    },
}) satisfies BetterAuthPlugin;
```

### Database Schema

The plugin extends the database with a `nearAccount` table:

```typescript
export const schema = {
    nearAccount: {
        fields: {
            userId: {
                type: "string",
                references: { model: "user", field: "id" },
                required: true,
            },
            accountId: { type: "string", required: true },
            network: { type: "string", required: true },
            publicKey: { type: "string", required: true },
            isPrimary: { type: "boolean", defaultValue: false },
            createdAt: { type: "date", required: true },
        },
    },
} satisfies AuthPluginSchema;
```

### API Endpoints

#### 1. Nonce Generation (`/near/nonce`)
Generates cryptographic nonces for signature verification:

```typescript
getSiwnNonce: createAuthEndpoint("/near/nonce", {
    method: "POST",
    body: NonceRequest, // { accountId: string }
}, async (ctx) => {
    const { accountId } = ctx.body;
    const network = getNetworkFromAccountId(accountId);
    const nonce = options.getNonce ? await options.getNonce() : generateNonce();
    
    // Store nonce with expiration
    await ctx.context.internalAdapter.createVerificationValue({
        identifier: `siwn:${accountId}:${network}`,
        value: bytesToBase64(nonce),
        expiresAt: new Date(Date.now() + 15 * 60 * 1000),
    });
    
    return ctx.json({ nonce: bytesToBase64(nonce) });
})
```

#### 2. Profile Retrieval (`/near/profile`)
Fetches user profiles from NEAR Social:

```typescript
getSiwnProfile: createAuthEndpoint("/near/profile", {
    method: "POST",
    body: ProfileRequest, // { accountId?: string }
    use: [sessionMiddleware],
}, async (ctx) => {
    const { accountId } = ctx.body;
    let targetAccountId = accountId;
    
    // If no accountId provided, use authenticated user's primary account
    if (!targetAccountId) {
        const session = ctx.context.session;
        if (!session) {
            throw new APIError("UNAUTHORIZED", {
                message: "Session required when no accountId provided",
            });
        }
        
        const nearAccount = await ctx.context.adapter.findOne({
            model: "nearAccount",
            where: [
                { field: "userId", operator: "eq", value: session.user.id },
                { field: "isPrimary", operator: "eq", value: true },
            ],
        });
        
        targetAccountId = nearAccount?.accountId;
    }
    
    const profile = await (options.getProfile || defaultGetProfile)(targetAccountId);
    return ctx.json(profile);
})
```

#### 3. Signature Verification (`/near/verify`)
Verifies NEAR signatures and creates/updates user sessions:

```typescript
verifySiwnMessage: createAuthEndpoint("/near/verify", {
    method: "POST",
    body: VerifyRequest.refine((data) => 
        options.anonymous !== false || !!data.email, {
        message: "Email is required when anonymous is disabled.",
        path: ["email"],
    }),
}, async (ctx) => {
    const { authToken, accountId, email } = ctx.body;
    
    // Retrieve and validate nonce
    const verification = await ctx.context.internalAdapter.findVerificationValue(
        `siwn:${accountId}:${network}`
    );
    
    // Verify signature using near-sign-verify
    const verifyOptions: VerifyOptions = {
        requireFullAccessKey: options.requireFullAccessKey ?? true,
        ...(options.validateNonce 
            ? { validateNonce: options.validateNonce }
            : { nonceMaxAge: 15 * 60 * 1000 }),
        ...(options.validateRecipient 
            ? { validateRecipient: options.validateRecipient }
            : { expectedRecipient: options.recipient }),
    };
    
    const result = await verify(authToken, verifyOptions);
    
    // Create or update user and NEAR account records
    // Create session and set cookies
    // Return authentication response
})
```

### Client Plugin Implementation

```typescript
export const siwnClient = (config: SIWNClientConfig) => ({
    id: "siwn",
    $InferServerPlugin: {} as ReturnType<typeof siwn>,
    getActions: ($fetch) => ({
        near: {
            nonce: async (params) => $fetch("/near/nonce", {
                method: "POST",
                body: params,
            }),
            verify: async (params) => $fetch("/near/verify", {
                method: "POST", 
                body: params,
            }),
            getProfile: async (accountId) => $fetch("/near/profile", {
                method: "POST",
                body: { accountId },
            }),
        },
        signIn: {
            near: async (params, callbacks) => {
                // Complete authentication flow
                const { recipient, signer } = params;
                
                const accountId = signer.accountId();
                if (!accountId) {
                    throw new Error("Wallet not connected");
                }
                
                // Get nonce
                const nonceResponse = await $fetch("/near/nonce", {
                    method: "POST",
                    body: { accountId }
                });
                
                // Sign message
                const message = `Sign in to ${recipient}\n\nAccount ID: ${accountId}\nNonce: ${nonceResponse.data.nonce}`;
                const authToken = await sign(message, {
                    signer,
                    recipient,
                    nonce: base64ToBytes(nonceResponse.data.nonce),
                });
                
                // Verify and authenticate
                const verifyResponse = await $fetch("/near/verify", {
                    method: "POST",
                    body: { authToken, accountId }
                });
                
                callbacks?.onSuccess?.();
                return verifyResponse.data;
            }
        }
    })
}) satisfies BetterAuthClientPlugin;
```

### Type Definitions

The plugin uses comprehensive Zod schemas for type safety:

```typescript
// Account ID validation
export const accountIdSchema = z.string()
    .min(2)
    .max(64)
    .regex(/^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/, 
           "Invalid NEAR account ID format");

// Profile structure from NEAR Social
export const profileSchema = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    image: z.object({
        url: z.string().optional(),
        ipfs_cid: z.string().optional(),
    }).optional(),
    backgroundImage: z.object({
        url: z.string().optional(),
        ipfs_cid: z.string().optional(),
    }).optional(),
    linktree: z.record(z.string(), z.string()).optional(),
});

// API request/response schemas
export const NonceRequest = z.object({ accountId: accountIdSchema });
export const VerifyRequest = z.object({
    authToken: z.string().min(1),
    accountId: accountIdSchema,
    email: z.email().optional(),
});
export const ProfileRequest = z.object({
    accountId: accountIdSchema.optional(),
});

export const NonceResponse = z.object({ nonce: z.string() });
export const VerifyResponse = z.object({
    token: z.string(),
    success: z.literal(true),
    user: z.object({
        id: z.string(),
        accountId: accountIdSchema,
        network: z.union([z.literal("mainnet"), z.literal("testnet")]),
    }),
});
```

## Integration Patterns

### Browser Wallet Integration

For browser-based authentication using NEAR wallets:

```html
<!-- Add to index.html -->
<script src="https://unpkg.com/fastintear@latest/dist/umd/browser.global.js"></script>
<script>
    window.near && window.near.config({ networkId: "mainnet" });
    
    if (typeof window.near !== "undefined") {
        console.log("NEAR (via global object 'near') is ready!");
    } else {
        console.error("NEAR global object 'near' not found!");
    }
</script>
```

```typescript
// Client configuration
export const authClient = createAuthClient({
    plugins: [
        siwnClient({
            domain: "myapp.com",
        })
    ],
});

// Usage
await authClient.signIn.near(
    { recipient: "myapp.com", signer: window.near },
    {
        onSuccess: () => console.log("Signed in!"),
        onError: (error) => console.error("Sign in failed:", error),
    }
);
```

## Configuration Options

### Server Plugin Options

```typescript
export type SIWNPluginOptions = {
    recipient: string;                    // Required: NEP-413 recipient
    anonymous?: boolean;                  // Allow anonymous sign-ins (default: true)
    emailDomainName?: string;            // Email domain for user accounts
    requireFullAccessKey?: boolean;       // Require full access keys (default: true)
    getNonce?: () => Promise<Uint8Array>; // Custom nonce generation
    validateNonce?: (nonce: Uint8Array) => boolean; // Custom nonce validation
    validateRecipient?: (recipient: string) => boolean; // Custom recipient validation
    validateMessage?: (message: string) => boolean; // Custom message validation
    getProfile?: (accountId: string) => Promise<Profile | null>; // Custom profile lookup
    validateLimitedAccessKey?: (args: {
        accountId: string;
        publicKey: string;
        recipient?: string;
    }) => Promise<boolean>; // Validate function call keys
};
```

### Advanced Configuration Example

```typescript
import { betterAuth } from "better-auth";
import { siwn } from "better-near-auth";
import { generateNonce } from "near-sign-verify";

const usedNonces = new Set<string>();

export const auth = betterAuth({
    plugins: [
        siwn({
            recipient: "myapp.com",
            anonymous: false,
            emailDomainName: "myapp.com",
            requireFullAccessKey: false,
            
            // Custom nonce generation
            getNonce: async () => generateNonce(),
            
            // Prevent replay attacks
            validateNonce: (nonce: Uint8Array) => {
                const nonceHex = Array.from(nonce)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                if (usedNonces.has(nonceHex)) {
                    return false;
                }
                usedNonces.add(nonceHex);
                return true;
            },
            
            // Allow multiple domains
            validateRecipient: (recipient: string) => {
                const allowedRecipients = [
                    "myapp.com", 
                    "staging.myapp.com", 
                    "localhost:3000"
                ];
                return allowedRecipients.includes(recipient);
            },
            
            // Custom profile lookup
            getProfile: async (accountId) => {
                try {
                    const response = await fetch(`https://api.myapp.com/profiles/${accountId}`);
                    if (response.ok) {
                        const customProfile = await response.json();
                        return {
                            name: customProfile.displayName,
                            description: customProfile.bio,
                            image: { url: customProfile.avatar },
                        };
                    }
                } catch (error) {
                    console.error("Custom profile fetch failed:", error);
                }
                return null; // Fallback to NEAR Social
            },
            
            // Validate function call keys
            validateLimitedAccessKey: async ({ accountId, publicKey, contractId }) => {
                const allowedContracts = ["myapp.near", "social.near"];
                return contractId ? allowedContracts.includes(contractId) : true;
            },
        }),
    ],
});
```

## Authentication Flow

### Complete Authentication Sequence

1. **Client Request**: User initiates sign-in
2. **Nonce Generation**: Server generates cryptographic nonce
3. **Message Signing**: Client signs NEP-413 message with wallet
4. **Signature Verification**: Server verifies signature using near-sign-verify
5. **User Creation/Lookup**: Create new user or find existing account
6. **Session Management**: Create session and set authentication cookies
7. **Profile Integration**: Fetch and store user profile from NEAR Social

### Error Handling

The plugin provides comprehensive error handling:

```typescript
// Common error scenarios
- UNAUTHORIZED_INVALID_OR_EXPIRED_NONCE: Nonce expired or invalid
- BAD_REQUEST: Missing required fields (email when anonymous=false)
- UNAUTHORIZED: Account ID mismatch or signature verification failed
- NOT_FOUND: No NEAR account found for authenticated user
- INTERNAL_SERVER_ERROR: Session creation failed
```

## Security Considerations

### NEP-413 Compliance
- Follows NEAR Enhancement Proposal 413 for secure message signing
- Implements proper nonce handling to prevent replay attacks
- Validates message format and recipient information

### Access Key Validation
- Supports both full access keys and function call access keys
- Configurable validation for limited access keys
- Contract-specific access control when using function call keys

### Session Security
- Secure cookie handling with proper expiration
- Session token generation and validation
- Multi-account support with primary account designation

## Network Support

### Automatic Network Detection
```typescript
export const getNetworkFromAccountId = (accountId: string): "mainnet" | "testnet" => {
    return accountId.endsWith(".testnet") ? "testnet" : "mainnet";
};
```

### Multi-Network Account Linking
- Supports both mainnet and testnet accounts
- Separate account records per network
- Network-specific nonce storage and validation

## Profile Integration

### NEAR Social Integration
The plugin automatically fetches user profiles from NEAR Social:

```typescript
export const defaultGetProfile = async (accountId: string): Promise<Profile | null> => {
    try {
        const network = getNetworkFromAccountId(accountId);
        const client = new FastNear({ network });
        
        const profile = await client.getProfile(accountId);
        return profile ? profileSchema.parse(profile) : null;
    } catch (error) {
        console.error("Failed to fetch profile:", error);
        return null;
    }
};
```

### Custom Profile Sources
Configure custom profile lookup functions:

```typescript
siwn({
    getProfile: async (accountId) => {
        // Custom profile logic
        const customProfile = await fetchFromCustomAPI(accountId);
        if (customProfile) {
            return {
                name: customProfile.displayName,
                description: customProfile.bio,
                image: { url: customProfile.avatar },
            };
        }
        // Fallback to NEAR Social
        return null;
    },
})
```

## Usage Examples

### Basic Setup

```typescript
// Server (auth.ts)
import { betterAuth } from "better-auth";
import { siwn } from "better-near-auth";

export const auth = betterAuth({
    database: drizzleAdapter(db),
    plugins: [
        siwn({
            recipient: "myapp.com",
            anonymous: true,
        }),
    ],
});

// Client (auth-client.ts)
import { createAuthClient } from "better-auth/client";
import { siwnClient } from "better-near-auth/client";

export const authClient = createAuthClient({
    plugins: [
        siwnClient({
            domain: "myapp.com",
        })
    ],
});
```

### React Component Example

```tsx
import { authClient } from "./auth-client";
import { useState } from "react";

export function LoginButton() {
    const { data: session } = authClient.useSession();
    const [isSigningIn, setIsSigningIn] = useState(false);

    if (session) {
        return (
            <div>
                <p>Welcome, {session.user.name}!</p>
                <button onClick={() => authClient.signOut()}>
                    Sign out
                </button>
            </div>
        );
    }

    const handleSignIn = async () => {
        setIsSigningIn(true);
        
        try {
            await authClient.signIn.near(
                { recipient: "myapp.com" },
                {
                    onSuccess: () => console.log("Successfully signed in!"),
                    onError: (error) => console.error("Sign in failed:", error.message),
                }
            );
        } catch (error) {
            console.error("Authentication error:", error);
        } finally {
            setIsSigningIn(false);
        }
    };

    return (
        <button onClick={handleSignIn} disabled={isSigningIn}>
            {isSigningIn ? "Signing in..." : "Sign in with NEAR"}
        </button>
    );
}
```

### Profile Access

```typescript
// Get current user's profile (requires authentication)
const myProfile = await authClient.near.getProfile();
console.log("My profile:", myProfile);

// Get specific user's profile (no auth required)
const aliceProfile = await authClient.near.getProfile("alice.near");
console.log("Alice's profile:", aliceProfile);
```

## Best Practices

### Security
1. Always validate nonces to prevent replay attacks
2. Use HTTPS in production for secure cookie transmission
3. Implement proper error handling and user feedback
4. Validate recipient domains to prevent phishing attacks

### Performance
1. Cache profile data when appropriate
2. Use connection pooling for database operations
3. Implement rate limiting for authentication endpoints
4. Consider CDN for static assets (fastintear scripts)

### User Experience
1. Provide clear error messages for authentication failures
2. Handle wallet connection states gracefully
3. Support both anonymous and email-required modes
4. Implement loading states during authentication

## Troubleshooting

### Common Issues

1. **"NEAR global object 'near' not found"**
   - Ensure fastintear script is loaded before your application code
   - Check browser console for script loading errors

2. **"Wallet not connected"**
   - User must connect wallet before attempting authentication
   - Implement wallet connection flow in your UI

3. **"Invalid or expired nonce"**
   - Nonces expire after 15 minutes by default
   - Ensure client and server clocks are synchronized

4. **"Account ID mismatch"**
   - Verify the signed message contains the correct account ID
   - Check for wallet switching during authentication flow

### Debug Mode

Enable debug logging for troubleshooting:

```typescript
// Add to your auth configuration
siwn({
    // ... other options
    validateMessage: (message: string) => {
        console.log("Validating message:", message);
        return true; // Add your validation logic
    },
    validateNonce: (nonce: Uint8Array) => {
        console.log("Validating nonce:", Array.from(nonce));
        return true; // Add your validation logic
    },
})
```

## Conclusion

The better-near-auth plugin demonstrates the power and flexibility of Better Auth's plugin architecture. By following the established patterns for server and client plugins, it provides a complete authentication solution that integrates seamlessly with the NEAR ecosystem while maintaining type safety and security best practices.

The plugin's modular design allows for extensive customization while providing sensible defaults for common use cases. Whether you're building a simple dApp or a complex federated service, better-near-auth provides the foundation for secure NEAR-based authentication.
